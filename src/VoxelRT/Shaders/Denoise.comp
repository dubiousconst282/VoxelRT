uniform mat4 u_InvProjMat;
uniform mat4 u_HistoryProjMat;
uniform vec3 u_OriginDelta;

#include "GBuffer.glsl"

void temporalReproject(inout GSample g, ivec2 pos) {
    ivec2 resolution = imageSize(u_GBuffer);
    vec2 uv = vec2(pos + 0.5) * (1.0 / resolution);

    vec3 rayDir, rayPos;
    getPrimaryRay(uv, u_InvProjMat, rayPos, rayDir);

    vec4 prevNDC = u_HistoryProjMat * vec4(rayPos + rayDir * g.depth + u_OriginDelta, 1.0);
    vec2 prevUV = prevNDC.xy * (1.0 / prevNDC.w);
    prevUV = prevUV * 0.5 + 0.5;

    // bounds check
    if (prevUV.x < 0 || prevUV.y < 0 || prevUV.x > 1.0 || prevUV.y > 1.0 || g.depth <= 0) return;

    ivec2 prevPos = ivec2(prevUV * resolution - 0.5);
    vec2 pf = fract(prevUV * resolution - 0.5);

    float wsum = 0.0;
    vec3 prevIrradiance = vec3(0);

    for (int i = 0; i < 4; i++) {
        GSample ng = gbufferLoad(prevPos + ivec2(i & 1, i >> 1), true);
        
        // if (dot(g.normal, ng.normal) < 0.7) continue;
        // if (distance(g.albedo, ng.albedo) > 0.15) continue;

        float w = mix(1 - pf.x, pf.x, (i & 1) != 0) *
                  mix(1 - pf.y, pf.y, (i >> 1) != 0);

        prevIrradiance += ng.irradiance * w;
        wsum += w;
    }

    if (wsum > 0.0) {
        prevIrradiance *= (1.0 / wsum);
        g.irradiance = mix(prevIrradiance, g.irradiance, 0.1);
    }
}

layout(local_size_x = 8, local_size_y = 8) in;
void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    GSample g = gbufferLoad(pos, false);

    temporalReproject(g, pos);

    gbufferStore(pos, g);
}