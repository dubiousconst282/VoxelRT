uniform int u_PassNo;
uniform mat4 u_InvProjMat;
uniform mat4 u_OldProjMat; // previous frame
uniform vec3 u_OriginDelta;

uniform bool u_DiscardAccumSamples;

#include "GBuffer.glsl"

float luma(vec3 color) {
    return dot(color, vec3(0.299, 0.587, 0.114));
}

// https://research.nvidia.com/sites/default/files/pubs/2017-07_Spatiotemporal-Variance-Guided-Filtering%3A//svgf_preprint.pdf
// https://www.shadertoy.com/view/tlXfRX

void temporalReproject(inout GSample g, ivec2 pos) {
    ivec2 resolution = imageSize(u_BackBuffer);
    vec2 uv = vec2(pos + 0.5) * (1.0 / resolution);

    vec3 rayDir, rayPos;
    getPrimaryRay(uv, u_InvProjMat, rayPos, rayDir);

    vec4 prevNDC = u_OldProjMat * vec4(rayPos + rayDir * g.depth + u_OriginDelta, 1.0);
    vec2 prevUV = prevNDC.xy * (1.0 / prevNDC.w);
    prevUV = prevUV * 0.5 + 0.5;

    // bounds check
    if (prevUV.x < 0 || prevUV.y < 0 || prevUV.x > 1.0 || prevUV.y > 1.0 || g.depth <= 0) return;

    ivec2 prevPos = ivec2(prevUV * resolution - 0.5);
    vec2 pf = fract(prevUV * resolution - 0.5);

    float wsum = 0.0;
    vec3 prevIrradiance = vec3(0);

    for (int i = 0; i < 4; i++) {
        GSample ng = gbufferLoad(prevPos + ivec2(i & 1, i >> 1), false);
        
        //if (dot(g.normal, ng.normal) < 0.7) continue;
        //if (distance(g.albedo, ng.albedo) > 0.15) continue;

        float w = mix(1 - pf.x, pf.x, (i & 1) != 0) *
                  mix(1 - pf.y, pf.y, (i >> 1) != 0);

        prevIrradiance += ng.irradiance * w;
        wsum += w;
    }

    if (wsum > 0.0) {
        prevIrradiance *= (1.0 / wsum);
        g.irradiance = mix(prevIrradiance, g.irradiance, 0.1);
    }
}
vec3 atrousFilter(ivec2 pos, GSample centerSample, int stepShift) {
    const float[5] kernel = { 0.0625, 0.25, 0.375, 0.25, 0.0625 };

    vec3 sum = vec3(0.0);
    float wsum = 0.0;

    const float normalPhi = 0.005;
    const float colorPhi = 0.0005;
    float stepWeightRsq = 1.0 / (1 << (stepShift * 2));

    for (int y = -2; y <= 2; y++) {
        for (int x = -2; x <= 2; x++) {
            ivec2 samplePos = pos + (ivec2(x, y) << stepShift);

            if (any(greaterThanEqual(uvec2(samplePos), uvec2(imageSize(u_BackBuffer))))) continue;

            GSample s = gbufferLoad(samplePos, true);

            float weight = 1.0;

            // Color weight, w_c
            vec3 t = centerSample.albedo - s.albedo;
            float dist2 = max(dot(t, t) * stepWeightRsq, 0.0);
            weight *= min(exp(-dist2 / colorPhi), 1.0);

            // Normal weight, w_n
            //weight *= pow(max(dot(centerSample.normal, s.normal), 0.0), 128);
            
            t = centerSample.normal - s.normal;
            dist2 = max(dot(t, t) * stepWeightRsq, 0.0);
            weight *= min(exp(-dist2 / normalPhi), 1.0);

            // Kernel weight h(q)
            weight *= kernel[x + 2] * kernel[y + 2];

            sum += (s.irradiance) * weight;
            wsum += weight;
        }
    }
    return (sum * (1.0 / wsum));
}

layout(local_size_x = 8, local_size_y = 8) in;
void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    GSample g = gbufferLoad(pos, true);

    if (u_PassNo == 0) {
        temporalReproject(g, pos);
    }
    if (u_PassNo > 1) {
        //g.irradiance = atrousFilter(pos, g, 2 - u_PassNo);
    }
    gbufferStore(pos, g);
}