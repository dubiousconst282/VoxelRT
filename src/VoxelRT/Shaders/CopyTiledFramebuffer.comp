#include "GBuffer.glsl"

readonly buffer ssbo_FrameData {
    uint Width, Height, Stride;
    uint TileShiftX, TileShiftY;
    uint Padding[11];
    uint PixelData[];
};

uint getPixelOffset(uvec2 pos) {
    uint FieldStride = 1u << (TileShiftX + TileShiftY);
    uint TileStride = (FieldStride * 4 + 15) & ~15;
    uint TileMaskX = (1u << TileShiftX) - 1;
    uint TileMaskY = (1u << TileShiftY) - 1;

    uint tileId = (pos.x >> TileShiftX) + (pos.y >> TileShiftY) * Stride;
    uint pixelOffset = (pos.x & TileMaskX) + ((pos.y & TileMaskY) << TileShiftX);
    return tileId * TileStride + pixelOffset;
}

layout(local_size_x = 8, local_size_y = 8) in;
void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    uint offset = getPixelOffset(uvec2(pos));

    uint FieldStride = 1u << (TileShiftX + TileShiftY);
    vec3 albedo = unpackUnorm4x8(PixelData[offset + FieldStride * 0]).rgb;
    vec3 normal = vec3(uvec3(PixelData[offset + FieldStride * 0]) >> uvec3(24, 26, 28) & 3u) - 1;
    float depth = uintBitsToFloat(PixelData[offset + FieldStride * 1]);
    vec2 irradianceRG = unpackHalf2x16(PixelData[offset + FieldStride * 2]);
    float irradianceB = unpackHalf2x16(PixelData[offset + FieldStride * 3]).r;

    if (depth < 0) albedo = vec3(1.0);
    
    imageStore(u_AlbedoNormalTex, pos, vec4(albedo, float(packGNormal(normal))));
    imageStore(u_IrradianceTex, pos, vec4(irradianceRG, irradianceB, 0));
    imageStore(u_DepthTex, pos, vec4(depth));
}