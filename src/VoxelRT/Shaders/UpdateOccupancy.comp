#include "VoxelMap.glsl"

readonly buffer ssbo_UpdateLocs {
    uint Count;
    uint BrickLocs[];
} b_Updates;

layout(local_size_x = 1, local_size_y = 1, local_size_z = 64) in;
void main() {
    if (gl_GlobalInvocationID.z >= b_Updates.Count) return;

    uvec3 brickPos;
    // Unpack tightly packed uvec3 array manually to workaround arcaic alignment rules.
    brickPos.x = b_Updates.BrickLocs[gl_GlobalInvocationID.z * 3 + 0];
    brickPos.y = b_Updates.BrickLocs[gl_GlobalInvocationID.z * 3 + 1];
    brickPos.z = b_Updates.BrickLocs[gl_GlobalInvocationID.z * 3 + 2];

    uint slot = getBrickDataSlot(brickPos);

    // Generate 64-bit occupancy masks in 4x2x4 (32) cells
    for (uint cy = 0; cy < BRICK_SIZE; cy += 2)
    for (uint cz = 0; cz < BRICK_SIZE; cz += 4)
    for (uint cx = 0; cx < BRICK_SIZE; cx += 4) {
        uint mask = 0;
        
        for (uint vy = 0; vy < 2; vy++)
        for (uint vz = 0; vz < 4; vz++)
        for (uint vx = 0; vx < 4; vx++) {
            bool occupied = getBrickVoxelId(slot, uvec3(cx + vx, cy + vy, cz + vz)) != 0;
            mask |= uint(occupied) << (vx + vz*4 + vy*16);
        }
        uint cellOffset = getLinearIndex(uvec3(cx, cy, cz) / uvec3(4, 4, 4), BRICK_SIZE / 4, BRICK_SIZE / 4);
        b_Occupancy.Data[slot * OCC_STRIDE + cellOffset * 2 + (cy/2%2)] = mask;
    }
}